<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content="热爱每一段代码"><meta name="author" content="买盐"><meta name="keywords" content=""><title>第六章、I/O流 - 买盐の笔迹</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.11",typing:{enable:!0,typeSpeed:75,cursorChar:"(͒˃⌂˂͒)",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}},search_path:"/local-search.xml"}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/rss2.xml" title="买盐の笔迹" type="application/rss+xml"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>买盐の笔迹</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="第六章、I/O流"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-07-29 23:15" pubdate>2021年7月29日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 56 分钟</span></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">第六章、I/O流</h1><div class="markdown-body"><h2 id="一、I-O流概述"><a href="#一、I-O流概述" class="headerlink" title="一、I/O流概述"></a><strong>一、I/O流概述</strong></h2><p>我们平时用键盘打字、显示器显示音频等等是如何实现的呢？这是要实现程序与设备之间的数据传输，而程序是通过<strong>流</strong>的方式与设备进行数据传输。流又是什么？可以将流想象成一个“水流管道”，水流就在这管道中将数据于设备之间进行交互。</p><p><strong>1.1.流的分类</strong></p><p>流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。</p><p>I/O流，即是输入输出流。流大致分三种：</p><ul><li><strong>字节流和字符流</strong></li></ul><blockquote><p>按照操作流的<strong>数据单位不同</strong>，分为字节流和字符流。字节流按一个字节或多个字节数据进行读写；字符流按一个字符或多个字符进行读写。</p></blockquote><ul><li><strong>输入流和输出流</strong></li></ul><blockquote><p>按照流<strong>传输方向不同</strong>，分为输入流和输出流。<strong>输入</strong>流从流中<strong>读</strong>数据，<strong>输出</strong>流往流中<strong>写</strong>数据。</p></blockquote><ul><li><strong>节点流和处理流</strong></li></ul><blockquote><p>按流的<strong>功能不同</strong>，分为节点流和处理流。<strong>节点流又称低级流</strong>，指只能<strong>直接连接数据源</strong>进行读写操作。<strong>处理流又称高级流</strong>，指对已存在的节点流连接、封装，通过封装后的流进行读写操作。处理流<strong>不会直接连接数据源</strong>。</p></blockquote><p><img src="https://pic1.zhimg.com/v2-b63f1cf4524763cd59a01b23ffc7d060_b.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><p><img src="https://pic2.zhimg.com/v2-945055e8a7499f6bf20b28df1d8988b9_b.gif" srcset="/img/loading.gif" lazyload alt="img"></p><h2 id="二、字节流"><a href="#二、字节流" class="headerlink" title="二、字节流"></a><strong>二、字节流</strong></h2><p><strong>2.1.字节流</strong></p><p>I/O流中针对字节的输入和输出提供了字节流。字节流按传输方向分为字节输入流和字节输出流。字节流的顶级父类：<strong>InputStream(输入-读)和OutputStream(输出-写)<strong>。这两个类都是抽象类，</strong>无法实例化</strong>。</p><p><strong>InputStream常用方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>read（）</td><td>从输入流读取一个8位的字节，把它转换为0～255之间的整数，并返回这一整数。当没有可用字节时，将返回一1。</td></tr><tr><td>read（byte[ ] b）</td><td>从输人流读取若干字节，把它们保存到参数b指定的字节数组中，返回的整数表示读取字节的数目。</td></tr><tr><td>read(byte [ ] b, int off ,int len )</td><td>读字节， off表示:起始下标 len： 字节数目。</td></tr><tr><td>close()</td><td>关闭流，释放资源。</td></tr></tbody></table><blockquote><p><strong>注意：</strong>I/O流会占用内存，所有得关闭流。</p></blockquote><p><img src="https://pic1.zhimg.com/v2-282b0fa81e95d0c524f3cc2cc5d1fe84_b.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong>OutputStream常用方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>write()</td><td>向输出流写一个字节。</td></tr><tr><td>write(byte[ ] b)</td><td>将字节数组b写到输出流中。</td></tr><tr><td>write(byte[ ] b,int off, int len )</td><td>将字节数组b从off索引坐标位置长度为len写到输出流中。</td></tr><tr><td>flush()</td><td>刷新，并强制写到输入流中。</td></tr><tr><td>close()</td><td>关闭流，释放资源。</td></tr></tbody></table><p><img src="https://pic2.zhimg.com/v2-f9d8f0fa44b1978f5083b6fcd6862751_b.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong>2.2.字节流读写文件</strong></p><p>文件的读写：就是从一个文件中读取数据并将数据写到另一个文件中。</p><p><strong>FileInputSream</strong>为InputSream的子类，用于<strong>读取数据</strong>。因为读取数据是一个重复过程，要通过循环语句来实现数据的<strong>持续</strong>读取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> *  从该目录中读取数据</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">     @Test</span><br><span class="line">public void Test01() throws Exception &#123;</span><br><span class="line">    FileInputStream fileInputStream = new FileInputStream(&quot;E:\\workSpace\\mine-study\\JavaEE\\01-javaHello\\src\\main\\resources\\test.txt&quot;);</span><br><span class="line">    //定义一个变量</span><br><span class="line">    int b = 0;</span><br><span class="line">    //通过循环语句达到持续读取</span><br><span class="line">    while ((b=fileInputStream.read())!=-1)&#123;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>我们得到结果是一些数字，那是因为读取时是以字节形式存在的，而这些<strong>数字对应了字节的ASCII码值</strong>。还需要注意在读取数据时的目录要是存在并可读的。<strong>返回-1</strong>是对的，read字节数组的时候，读到最后一个没有的时候就数组越界异常，-<strong>1就是不在数组的索引值范围内</strong>，所以开发人员就将它作为read完成后的返回值。</p></blockquote><p><strong>FileOutputSream</strong>为OutputStream的子类，用于<strong>写数据</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从目录写数据</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void Test02() throws Exception &#123;</span><br><span class="line">    //创建文件输出流，并指定要写入的文件名</span><br><span class="line">    FileOutputStream fileOutputStream = new FileOutputStream(&quot;E:\\workSpace\\mine-study\\JavaEE\\01-javaHello\\src\\main\\resources\\test.txt&quot;,true);</span><br><span class="line">    //定义一个字符串</span><br><span class="line">    String s = &quot;Hello&quot;;</span><br><span class="line">    //将字符串转化为字节数组进行写入操作</span><br><span class="line">    fileOutputStream.write(s.getBytes());</span><br><span class="line">    //关闭流</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>没有指定目录，就会自动创建一个该文件。而已存在的话，会<strong>先清空该文件内容，再将要写的数据写入</strong>。想要不被清除之前的数据，就在<strong>参数中写true</strong>即可。<br>如果出现io异常，是会影响关闭io流关闭，这样就会占用内存。通过使用<strong>finally将io流关闭</strong>。以保证无法关闭流。</p></blockquote><p><strong>2.3.文件的复制</strong></p><p>那文件的拷贝就是同时使用了两种流，一边读数据，一边写数据。就形成文件拷贝了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现文件的复制</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void Test03() throws Exception &#123;</span><br><span class="line">    //先读取文件</span><br><span class="line">    FileInputStream fileInputStream = new FileInputStream(&quot;./TestFile01/01.gif&quot;);</span><br><span class="line">    //写文件</span><br><span class="line">    FileOutputStream fileOutputStream = new FileOutputStream(&quot;./TestFile01/TestFile02&quot;);</span><br><span class="line">    //定义一个变量</span><br><span class="line">    int len = 0;</span><br><span class="line">    long beforeTime = System.currentTimeMillis();</span><br><span class="line">    //通过循环持续读取</span><br><span class="line">    while ((len=fileInputStream.read())!=-1)&#123;</span><br><span class="line">        fileOutputStream.write(len);</span><br><span class="line">    &#125;</span><br><span class="line">    long afterTime = System.currentTimeMillis();</span><br><span class="line">    long l = afterTime - beforeTime;</span><br><span class="line">    System.out.println(&quot;花费时间：&quot;+l);</span><br><span class="line"></span><br><span class="line">    //关闭流</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.4.字节流缓冲区</strong></p><p>如果一个字节一个字节进行读取、写入，效率低。为了提高效率，采用定义一个<strong>字节数组作为缓冲区</strong>。这样就可以一次性读取多个字节的数据。将数据先保存到字节数组，将一整个字节数组一次性写到要放入的位置。缓冲区主要还是暂存数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 使用缓冲区高效读写</span><br><span class="line">  */</span><br><span class="line"> @Test</span><br><span class="line"> public void  Test04() throws Exception &#123;</span><br><span class="line">     //先读取文件</span><br><span class="line">     FileInputStream fileInputStream = new FileInputStream(&quot;./TestFile01/01.gif&quot;);</span><br><span class="line">     //写文件</span><br><span class="line">     FileOutputStream fileOutputStream = new FileOutputStream(&quot;./TestFile01/TestFile02&quot;);</span><br><span class="line">     //定义一个变量</span><br><span class="line">     int len = 0;</span><br><span class="line">     //定义一个长度为1024的字节数组作为缓冲区</span><br><span class="line">     byte[] bytes = new byte[1024];</span><br><span class="line">     long beforeTime = System.currentTimeMillis();</span><br><span class="line">     //通过循环持续读取</span><br><span class="line">     while ((len=fileInputStream.read(bytes))!=-1)&#123;</span><br><span class="line">         fileOutputStream.write(bytes,0,len);</span><br><span class="line">     &#125;</span><br><span class="line">     long afterTime = System.currentTimeMillis();</span><br><span class="line">     long l = afterTime - beforeTime;</span><br><span class="line">     System.out.println(&quot;花费时间：&quot;+l);</span><br><span class="line"></span><br><span class="line">     //关闭流</span><br><span class="line">     fileInputStream.close();</span><br><span class="line">     fileOutputStream.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>2.5.字节缓冲流</strong></p><p>字节缓冲流分为输入和输出：BufferedInputStream和BufferedOutputStream。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 字节缓冲流</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void Test05() throws Exception&#123;</span><br><span class="line">    //创建用于输入（读）和输出（写）的字节缓冲流对象</span><br><span class="line">    BufferedInputStream buffInS = new BufferedInputStream(new FileInputStream(&quot;./TestFile01/01.gif&quot;));</span><br><span class="line">    BufferedOutputStream buffOutS= new BufferedOutputStream(new FileOutputStream(&quot;./TestFile01/TestFile02&quot;));</span><br><span class="line">    //定义一个变量len</span><br><span class="line">    int len = 0;</span><br><span class="line">    //获取系统时间</span><br><span class="line">    long beforeTime = System.currentTimeMillis();</span><br><span class="line">    // 通过循环持续读取和写</span><br><span class="line">    while ((buffInS.read())!=-1)&#123;</span><br><span class="line">        buffOutS.write(len);</span><br><span class="line">    &#125;</span><br><span class="line">    long afterTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(&quot;所用时间：&quot;+(afterTime - beforeTime));</span><br><span class="line">    //关闭流</span><br><span class="line">    buffInS.close();</span><br><span class="line">    buffOutS.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>这两个缓冲流会在内部定义一个大小为<strong>8192</strong>的字节数组，通过读写将数据存到定义好的字节数组中。有效提高效率。</p></blockquote><p><img src="https://pic4.zhimg.com/v2-8bf9d539b533c04508b272fe4e0d23a3_b.gif" srcset="/img/loading.gif" lazyload alt="img"></p><h2 id="三、字符流"><a href="#三、字符流" class="headerlink" title="三、字符流"></a><strong>三、字符流</strong></h2><p><strong>3.1.字符流</strong></p><p>字符流拥有两个顶级的父类，<strong>Reader</strong>（字符输入流）和<strong>Writer</strong>（字符输出流）。</p><p><img src="https://pic4.zhimg.com/v2-3f7fb43f905b8637148864e39ea9af97_b.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><p><img src="https://pic3.zhimg.com/v2-3cf15e39b54bbdb6cc21f2b16de983e2_b.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong>3.2.字符流操作文件</strong></p><p>从文件中读取数据使用<strong>FileReader</strong>，注意要将int类型的len变量转换为char类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 字符流操作文件</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line"> @Test</span><br><span class="line"> public void Test06() throws Exception &#123;</span><br><span class="line">    //创建FileReader对象，并指定要读取的文件</span><br><span class="line">     FileReader reader = new FileReader(&quot;reader.txt&quot;);</span><br><span class="line">     //定义一个变量</span><br><span class="line">     int len = 0;</span><br><span class="line">     //通过循环区判断是否读取到文件末尾</span><br><span class="line">     while ((len= reader.read())!=-1)&#123;</span><br><span class="line">         System.out.println((char)len);</span><br><span class="line">     &#125;</span><br><span class="line">     reader.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>往文件中写数据使用<strong>FileWriter</strong>,注意文件不存在就会创建并写入数据，<strong>存在</strong>就<strong>清空当前文件内再直接写入数据</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 字符流写数据操作</span><br><span class="line">  */</span><br><span class="line"> @Test</span><br><span class="line"> public void Test07() throws Exception &#123;</span><br><span class="line">     //创建字符输出流FileWriter，向指定文件写数据</span><br><span class="line">     FileWriter writer = new FileWriter(&quot;reader.txt&quot;);</span><br><span class="line">     //对象调用写方法</span><br><span class="line">     writer.write(&quot;我的小雪最可爱&quot;);</span><br><span class="line">     //关闭流</span><br><span class="line">     writer.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>3.3.转换流</strong></p><p>也就是字节流和字符流之间的转换，InputStreamReader(读-<strong>字节变成字符</strong>)、OutputStreamWriter(写-<strong>字节边字符</strong>)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 转换流：字节变字符</span><br><span class="line">  */</span><br><span class="line"> @Test</span><br><span class="line"> public void Test08() throws Exception &#123;</span><br><span class="line">     //创建字节输入流对象，获取数据</span><br><span class="line">     FileInputStream inputStream = new FileInputStream(&quot;reader.txt&quot;);</span><br><span class="line">     //将字节流转换字符流</span><br><span class="line">     InputStreamReader reader = new InputStreamReader(inputStream);</span><br><span class="line">     //再变成缓冲流</span><br><span class="line">     BufferedReader bufferedReader = new BufferedReader(reader);</span><br><span class="line"></span><br><span class="line">     //创建字节输入流</span><br><span class="line">     FileOutputStream outputStream = new FileOutputStream(&quot;W.txt&quot;,true);</span><br><span class="line">     //将字节流转换字符流</span><br><span class="line">     OutputStreamWriter writer = new OutputStreamWriter(outputStream);</span><br><span class="line">     //再变成输入缓冲流</span><br><span class="line">     BufferedWriter bufferedWriter = new BufferedWriter(writer);</span><br><span class="line"></span><br><span class="line">     //定义一个长度变量</span><br><span class="line">     String len = null;</span><br><span class="line">     //通过持续读</span><br><span class="line">     while ((len=bufferedReader.readLine())!=null)&#123;</span><br><span class="line">         //写数据</span><br><span class="line">         bufferedWriter.write(len);</span><br><span class="line">         bufferedWriter.newLine();</span><br><span class="line">     &#125;</span><br><span class="line">     //关闭流</span><br><span class="line">     bufferedReader.close();</span><br><span class="line">     bufferedWriter.close();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>使用转换流，只能针对操作文件的字节流进行转换。</p></blockquote><p><img src="https://pic4.zhimg.com/v2-3ae4e06fe57f30d5aa0b1cc6aef03cc3_b.gif" srcset="/img/loading.gif" lazyload alt="img"></p><h2 id="四、File类"><a href="#四、File类" class="headerlink" title="四、File类"></a><strong>四、File类</strong></h2><p>现在我们能操作文件中的数据，但是无法操作文件本身。于是提供了<strong>File类来操作文件</strong>。</p><p><strong>4.1.File类常用方法</strong></p><p><img src="https://pic1.zhimg.com/v2-36e4fa7c32f9e93731fde1d624969844_b.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * File类的常用方法</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void Test09() throws Exception &#123;</span><br><span class="line">        //创建File文件、对象</span><br><span class="line">        File file = new File(&quot;R.txt&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;获取文件名：&quot;+file.getName());</span><br><span class="line">        System.out.println(&quot;获取文件绝对路径：&quot;+file.getAbsoluteFile());</span><br><span class="line">        System.out.println(&quot;获取文件相对路径：&quot;+file.getPath());</span><br><span class="line">        System.out.println(&quot;获取文件的父路径：&quot;+file.getParent());</span><br><span class="line">        System.out.println(&quot;文件是否可读：&quot;+file.canRead());</span><br><span class="line">        System.out.println(&quot;文件是否可写：&quot;+file.canWrite());</span><br><span class="line">        System.out.println(&quot;文件是否是文件：&quot;+file.isFile());</span><br><span class="line">        System.out.println(&quot;文件是否是是绝对路径：&quot;+file.isAbsolute());</span><br><span class="line">        System.out.println(&quot;文件是否是是一个目录：&quot;+file.isDirectory());</span><br><span class="line">        System.out.println(&quot;文件最后修改时间：&quot;+file.lastModified());</span><br><span class="line">        System.out.println(&quot;文件大小：&quot;+file.length()+&quot;个字节&quot;);</span><br><span class="line">//      System.out.println(&quot;文件是否删除成功：&quot;+file.delete());</span><br><span class="line"></span><br><span class="line">        Date date = new Date(file.lastModified());</span><br><span class="line">        SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>4.2.遍历目录下的文件</strong></p><p>File类中有一个<strong>list()<strong>方法用于遍历指定目录</strong>下</strong>的所有文件名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 遍历该目录下的文件名称</span><br><span class="line">  */</span><br><span class="line"> @Test</span><br><span class="line"> public void Test10()&#123;</span><br><span class="line">     //创建File对象，并指定文件名</span><br><span class="line">     File file = new File(&quot;E:\\workSpace\\mine-study\\JavaEE\\01-javaHello\\src\\main\\java\\com&quot;);</span><br><span class="line">     //判断是否目录</span><br><span class="line">     if (file.isDirectory())&#123;</span><br><span class="line">         //获取目录中所有的文件名称</span><br><span class="line">         String[] list = file.list();</span><br><span class="line">         for (String s : list) &#123;</span><br><span class="line">             System.out.println(s);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>4.3.删除文件、目录</strong></p><p>操作文件时会经常删除某个文件或整个文件，使用**delete()**方法来实现。</p><p><img src="https://pic1.zhimg.com/v2-360a8ac131b2c3e7e71e63de0311fd68_b.gif" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong>五、RandomAccessFile</strong></p><p>**5.1.**RandomAccessFile可以将文件指定的操作权限的方式打开。</p><blockquote><p>可以随机从文件的任何位置开始执行读写数据的操作。RandomAccessFile不属于流。<br>之前的IO流都有一个共同的特点：都是按照数据的先后顺序向目标设备写入数据的。</p></blockquote><p>RandomAccessFile<strong>构造方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>RandomAccessFile(File file , String mode)</td><td>file是指定被访问的文件，mode是要指定访问模式</td></tr><tr><td>RandomAccessFile（String name，String mode）</td><td>name是被访问的文件路径，mode是要指定访问模式</td></tr></tbody></table><blockquote><p><strong>mode：</strong>1. r：表示只读模式打开文件 2. rw：读写模式打开文件<br>\3. rws：读写模式打开文件，相比要同步文件到底层存储设备中<br>\4. rwd：读写模式打开文件 ，相比每一个都要更新要到底层存储设备中</p></blockquote><p>RandomAccessFile内部采用<strong>记录指针</strong>来标识当前读写位置。</p><p><img src="https://pic1.zhimg.com/v2-02eb27eb834595be470c88ae458c82d0_b.gif" srcset="/img/loading.gif" lazyload alt="img"></p><h2 id="六、对象序列化（Serializeable）"><a href="#六、对象序列化（Serializeable）" class="headerlink" title="六、对象序列化（Serializeable）"></a><strong>六、对象序列化（Serializeable）</strong></h2><p><strong>对象序列化能干什么？</strong></p><blockquote><p>将一些数据永远的保存到磁盘中，但是java中都用对象来保存数据。对象序列化则可以将对象中的数据保存到磁盘中。</p></blockquote><p><strong>对象的序列化：</strong>是指将java对象转换成I/O流中字节序列的过程。<strong>通过实现接口</strong></p><blockquote><p><strong>原理：</strong>对象序列化机制使Java对象转换成与平台无关的<strong>二进制流</strong>，将二进制流保存到磁盘，还可以通过网络将二进制流传输到另一个网络节点，也可以恢复原来的Java对象。也称为饭序列化。</p></blockquote><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要信息</td><td>自定义存储必要信息</td></tr><tr><td>性能差</td><td>性能好</td></tr></tbody></table><p><img src="https://pic4.zhimg.com/v2-ee3b143a27555505817ffc695ceeb883_b.gif" srcset="/img/loading.gif" lazyload alt="img"></p><h2 id="七、NIO"><a href="#七、NIO" class="headerlink" title="七、NIO"></a><strong>七、NIO</strong></h2><p><strong>7.1.NIO是什么？</strong></p><p>NIO相比IO提供了不同工作方式，NIO采用<strong>内存映射文件</strong>的方式来处理输入输出，将文件或文件的一段区域映射到内存中，就可以访问内存一样访问文件。</p><blockquote><p>标准的I/O流中使用的是字节流和字符流，<strong>NIO中使用通道、缓冲器、选择器</strong>。<br>数据总会从通道读入缓冲区，再从缓冲区写到通道。</p></blockquote><p><strong>NIO的三大核心部分：</strong></p><ul><li><strong>Buffer（</strong>缓冲器<strong>）：</strong>就相当于一个暂时的容器，本质为数组缓冲区。一开始数据会先放缓冲区暂存，然后再放到通道里。</li><li><strong>Channel(<strong>通道</strong>)：</strong>跟之前的标准I/O一样，所有数据以通过通道流的形式进行传输。</li><li><strong>Selector(<strong>选择器</strong>)：</strong>用于监听多个通道中的事件(打开通道、数据到达、等)，主要作用多线程的处理。</li></ul><p><img src="https://pic3.zhimg.com/v2-20492f674a9f28d62331c63c4aca31f6_b.jpg" srcset="/img/loading.gif" lazyload alt="img"></p><p><strong>7.2.Buffer(缓冲器)</strong></p><p>缓冲器会和通道进行交互，Buffer类似数组，将数据暂时存放。那么对于缓冲器就要三个概念</p><ol><li>**capacity(容量): **就是缓冲器能存放多少数据量，容量不能为0。</li><li><strong>limit(界限)：</strong>（索引0~limit）是可以进行读取操作，limit值不为负值。</li><li><strong>position(位置)：</strong>就是要进行读写操作的索引下标位置。默认为0，读写就移动位置。</li></ol><p><strong>7.3.Buffer常用方法</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>capacity()</td><td>获取缓冲区的大小</td></tr><tr><td>clear()</td><td>清除缓冲区，将位置设置为0，界限为容量</td></tr><tr><td>flip()</td><td>反转缓冲区，将界限设置为当前位置，再将位置设置为0</td></tr><tr><td>hasRemaining()</td><td>判断当前位置和界限是否有元素</td></tr><tr><td>limit</td><td>获取缓冲器的limit位置</td></tr><tr><td>limit(int newLimit)</td><td>设置limit值，返回新的缓冲区对象</td></tr><tr><td>mark()</td><td>设置标记</td></tr><tr><td>position()</td><td>获取position值</td></tr><tr><td>position(int newPosition)</td><td>设置position值，并返回被修改的对象</td></tr><tr><td>remaining()</td><td>获取当前位置和界限之间的元素个数</td></tr><tr><td>reset()</td><td>将缓冲区位置重置到标记处</td></tr><tr><td>rewind()</td><td>反缓冲区，将position设置为0，并取消标记</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test01()&#123;</span><br><span class="line">    //创建CharBuffer对象，并指定缓冲区容量大小为6</span><br><span class="line">    CharBuffer charBuffer = CharBuffer.allocate(6);</span><br><span class="line">    //展示容量、界限、位置</span><br><span class="line">    System.out.println(&quot;容量大小：&quot;+charBuffer.capacity());</span><br><span class="line">    System.out.println(&quot;界限大小：&quot;+charBuffer.limit());</span><br><span class="line">    System.out.println(&quot;位置大小：&quot;+charBuffer.position());</span><br><span class="line"></span><br><span class="line">    //向缓冲区对象放入3个元素</span><br><span class="line">    charBuffer.put(&#x27;A&#x27;);</span><br><span class="line">    charBuffer.put(&#x27;C&#x27;);</span><br><span class="line">    charBuffer.put(&#x27;B&#x27;);</span><br><span class="line">    System.out.println(&quot;放入元素后容量大小：&quot;+charBuffer.capacity());</span><br><span class="line">    System.out.println(&quot;放入元素后界限大小：&quot;+charBuffer.limit());</span><br><span class="line">    System.out.println(&quot;放入元素后位置大小：&quot;+charBuffer.position());</span><br><span class="line"></span><br><span class="line">    //执行flip()方法</span><br><span class="line">    charBuffer.flip();</span><br><span class="line">    System.out.println(&quot;反转缓冲区后容量大小：&quot;+charBuffer.capacity());</span><br><span class="line">    System.out.println(&quot;反转缓冲区界限大小：&quot;+charBuffer.limit());</span><br><span class="line">    System.out.println(&quot;反转缓冲区后位置大小：&quot;+charBuffer.position());</span><br><span class="line"></span><br><span class="line">    //操作缓冲区</span><br><span class="line">    System.out.println(&quot;获取缓冲区第一个元素：&quot;+charBuffer.get());</span><br><span class="line">    System.out.println(&quot;取出元素后索引大小：&quot;+charBuffer.limit());</span><br><span class="line">    System.out.println(&quot;取出元素后位置大小：&quot;+charBuffer.position());</span><br><span class="line"></span><br><span class="line">    //清除</span><br><span class="line">    charBuffer.clear();</span><br><span class="line">    System.out.println(&quot;取出元素后索引大小：&quot;+charBuffer.limit());</span><br><span class="line">    System.out.println(&quot;取出元素后位置大小：&quot;+charBuffer.position());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.4.Channel(通道)</strong></p><p>通道是一个<strong>接口对象</strong>，通道可以<strong>异步</strong>执行IO读写、通道读写是<strong>双向</strong>的，io流通常为单向、通道可以直接将指定文件的部分或者全部直接<strong>映射为buffer</strong>、通道<strong>只能与buffer交互</strong>。</p><p>通过io中的<strong>getChannel()方法获取通道对象</strong></p><p>7.5.File工具类</p><p><strong>该接口用于文件系统中定位文件对象，通常表示一个依赖通过文件路径。</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>endsWith(String s)</td><td>判断当前这个路径是否以s字符串结尾</td></tr><tr><td>getName(int index)</td><td>通过index获取元素作为路径对象</td></tr><tr><td>getNameCount()</td><td>返回路径中元素的数量</td></tr><tr><td>getParent()</td><td>获取父路径，没有返回null</td></tr><tr><td>getRoot()</td><td>获取根路径作为路径对象</td></tr><tr><td>toAbsolutePath()</td><td>获取绝对路径作为路径对象</td></tr><tr><td>toUri()</td><td>获取路径的URI地址</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line">public  void test02()&#123;</span><br><span class="line">    //使用paths的get（）方法创建path对象</span><br><span class="line">    Path path = Paths.get(&quot;E:\\workSpace\\mine-study\\JavaEE\\01-javaHello\\R.txt&quot;);</span><br><span class="line">    //输出path对象信息</span><br><span class="line">    System.out.println(&quot;根路径：&quot;+path.getRoot());</span><br><span class="line">    System.out.println(&quot;父路径：&quot;+path.getParent());</span><br><span class="line">    System.out.println(&quot;路径名称数：&quot;+path.getNameCount());</span><br><span class="line">    //遍历出每一个路径名称</span><br><span class="line">    for (int i = 0; i &lt;path.getNameCount() ; i++) &#123;</span><br><span class="line">        Path name = path.getName(i);</span><br><span class="line">        System.out.println(&quot;索引为：&quot;+i+&quot;的路径名称&quot;+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;URI路径：&quot;+path.toUri());</span><br><span class="line">    System.out.println(&quot;绝对路径：&quot;+path.toAbsolutePath());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.5.File工具类</strong></p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>createDirectories(path dir,FileAttribute&lt;?&gt; atts)</td><td>创建多级文件目录</td></tr><tr><td>createDirectories(path p,FileAttribute atts)</td><td>创建一个新的空文件p p存在则创建失败，atts为复制参数</td></tr><tr><td>copy(path s,path t ,CopyOtion c)</td><td>将一个文件s复制c到目标文件t</td></tr><tr><td>List<string>readAllLines(path p)</string></td><td>从文件p读取所有行</td></tr><tr><td>long size(Path p)</td><td>获取文件大小</td></tr><tr><td>Stream<path>list(Path dir)</path></td><td>将指定路径转换为Stream流</td></tr><tr><td>path write(Path p,Iterable&lt;?extends CharSequence&gt; lines, OpenOtion o)</td><td>将文本行写入文件，并传入指定写入模式</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line">public void Test03() throws Exception &#123;</span><br><span class="line">    //定义一个目录路径的path对象</span><br><span class="line">    Path dir = Paths.get(&quot;E:\\workSpace\\mine-study\\JavaEE\\01-javaHello&quot;);</span><br><span class="line">    //创建多级目录</span><br><span class="line">    Files.createDirectories(dir);</span><br><span class="line">    //使用paths的get（）方法创建path对象</span><br><span class="line">    Path path = Paths.get(&quot;E:\\workSpace\\mine-study\\JavaEE\\01-javaHello\\t.txt&quot;);</span><br><span class="line">    //创建一个文件</span><br><span class="line">    System.out.println(Files.createFile(path));</span><br><span class="line">    //创建一个集合</span><br><span class="line">    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(&quot;测试文件&quot;);</span><br><span class="line"></span><br><span class="line">    Files.write(path,list, StandardOpenOption.APPEND);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; lines = Files.readAllLines(path);</span><br><span class="line">    System.out.println(&quot;文件大小：&quot;+Files.size(path));</span><br><span class="line">    System.out.println(&quot;文件内容：&quot;+lines);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/v2-ac88922f58c1c5a86c93cdd19b2bc476_b.gif" srcset="/img/loading.gif" lazyload alt="img"></p></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/IO%E6%B5%81/">IO流</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/post/000c0e30-f0e1-11eb-aee4-2f9809b08461/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">第七章、JDBC</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/post/000c3540-f0e1-11eb-aee4-2f9809b08461/"><span class="hidden-mobile">第五章、集合容器</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments" lazyload><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config=function(){this.page.url="http://example.com/post/000c0e34-f0e1-11eb-aee4-2f9809b08461/",this.page.identifier="/post/000c0e34-f0e1-11eb-aee4-2f9809b08461/"};Fluid.utils.loadComments("#disqus_thread",(function(){var e=document,t=e.createElement("script");t.src="//fluid.disqus.com/embed.js",t.setAttribute("data-timestamp",new Date),(e.head||e.body).appendChild(t)}))</script><noscript>Please enable JavaScript to view the comments</noscript></div></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/boot.js"></script><script type="text/javascript" color="220,220,220" opacity="0.7" zindex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script type="text/javascript" src="/js/love.js"></script><script type="text/javascript" src="\js\snow.js"></script><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"right",width:150,height:300,mobile:{show:!0}},log:!1})</script></body></html>